//
// File: hsvAnomalyClassification.cpp
//
// MATLAB Coder version            : 3.1
// C/C++ source code generated on  : 05-Apr-2017 07:49:52
//

// Include Files
#include "rt_nonfinite.h"
#include "hsvAnomalyClassification.h"
#include "repmat.h"

// Function Declarations
static void logsig_apply(const double n[640000], double a[640000]);
static void mapminmax_apply(const double x[640000], double settings_xoffset,
  double settings_gain, double settings_ymin, double y[640000]);
static void tansig_apply(const double n[3200000], double a[3200000]);

// Function Definitions

//
// Arguments    : const double n[640000]
//                double a[640000]
// Return Type  : void
//
static void logsig_apply(const double n[640000], double a[640000])
{
  int k;

  //  Sigmoid Positive Transfer Function
  for (k = 0; k < 640000; k++) {
    a[k] = 1.0 / (1.0 + exp(-n[k]));
  }
}

//
// Arguments    : const double x[640000]
//                double settings_xoffset
//                double settings_gain
//                double settings_ymin
//                double y[640000]
// Return Type  : void
//
static void mapminmax_apply(const double x[640000], double settings_xoffset,
  double settings_gain, double settings_ymin, double y[640000])
{
  int ak;
  static double a[640000];
  int ck;
  double b_y;

  //  ===== MODULE FUNCTIONS ========
  //  Map Minimum and Maximum Input Processing Function
  ak = 0;
  for (ck = 0; ck < 640000; ck++) {
    b_y = x[ak] - settings_xoffset;
    ak++;
    a[ck] = b_y;
  }

  ak = 0;
  for (ck = 0; ck < 640000; ck++) {
    y[ck] = a[ak] * settings_gain;
    ak++;
  }

  memcpy(&a[0], &y[0], 640000U * sizeof(double));
  ak = 0;
  for (ck = 0; ck < 640000; ck++) {
    y[ck] = a[ak] + settings_ymin;
    ak++;
  }
}

//
// Arguments    : const double n[3200000]
//                double a[3200000]
// Return Type  : void
//
static void tansig_apply(const double n[3200000], double a[3200000])
{
  int k;

  //  Sigmoid Symmetric Transfer Function
  for (k = 0; k < 3200000; k++) {
    a[k] = 2.0 / (1.0 + exp(-2.0 * n[k])) - 1.0;
  }
}

//
// MYNEURALNETWORKFUNCTION neural network simulation function.
//
//  Generated by Neural Network Toolbox function genFunction, 05-Apr-2017 07:29:33.
//
//  [y1] = myNeuralNetworkFunction(x1) takes these arguments:
//    x = Qx3 matrix, input #1
//  and returns:
//    y = Qx1 matrix, output #1
//  where Q is the number of samples.
// Arguments    : const double x1[1920000]
//                double b_y1[640000]
// Return Type  : void
//
void hsvAnomalyClassification(const double x1[1920000], double b_y1[640000])
{
  static double b_x1[640000];
  static double xp1[640000];
  static double a1[3200000];
  static double b_a1[3200000];
  int i0;
  int i1;
  static double dv0[640000];
  static const double a[5] = { -13.966699436485008, 12.671950934858726,
    -10.962809145019886, -7.81963032539857, 8.6909031164543773 };

  double d0;
  static const double b_a[5] = { -4.164090338331305, 6.1659322682882776,
    5.43109680773958, 2.8901758542454292, 4.2514231319087052 };

  //  ===== NEURAL NETWORK CONSTANTS =====
  //  Input 1
  //  Layer 1
  //  Layer 2
  //  ===== SIMULATION ========
  //  Dimensions
  //  samples
  //  Input 1
  //  Remove Constants Input Processing Function
  memcpy(&b_x1[0], &x1[1280000], 640000U * sizeof(double));
  mapminmax_apply(b_x1, 0.0, 2.0, -1.0, xp1);

  //  Layer 1
  repmat(a1);
  for (i0 = 0; i0 < 5; i0++) {
    for (i1 = 0; i1 < 640000; i1++) {
      b_a1[i0 + 5 * i1] = a1[i0 + 5 * i1] + a[i0] * xp1[i1];
    }
  }

  tansig_apply(b_a1, a1);

  //  Layer 2
  for (i0 = 0; i0 < 640000; i0++) {
    d0 = 0.0;
    for (i1 = 0; i1 < 5; i1++) {
      d0 += b_a[i1] * a1[i1 + 5 * i0];
    }

    dv0[i0] = -0.14675560896054976 + d0;
  }

  logsig_apply(dv0, xp1);

  //  Output 1
  memcpy(&b_y1[0], &xp1[0], 640000U * sizeof(double));
}

//
// File trailer for hsvAnomalyClassification.cpp
//
// [EOF]
//
